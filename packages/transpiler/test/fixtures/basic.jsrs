pub fn add(a: i32, b: i32) -> i32 {
  a + b
}

pub enum Option<T> {
  Some(T),
  None,
}

pub fn match_test(a: Option<Option<i32>>) -> Option<i32> {
  let A(B(x), C(y)) = a else { return Option::None; };
  return Option::Some(x + y);
}

pub struct A {
  a: i32,
  b: i32,
}

impl A {
  pub fn new(a: i32, b: i32) -> A {
    A { a, b }
  }

  pub fn add(&self) -> i32 {
    self.a + self.b
  }
}

fn swap(a: &mut i32, b: &mut i32) {
  let tmp = *a;
  *a = *b;
  *b = tmp;
}

pub fn main() {
  let mut a = 1;
  let mut b = 2;
  swap(&mut a, &mut b);
}

pub fn is_alpha(c: char) -> bool {
  match c {
    'x' => {
      console.log("x");
      true
    }, 
    'a'..='z' | 'A'..='Z' => true,
    _ => false,
  }
}
